{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Sql-operator \u00b6 SQL-operator is a component that managed SQL resources for you. SQL-operator is implemented as a Kubernetes CRD (Custom Resource Definition). Create SQL assets using Infrastructure as Code . Easily create and destroy integration environments. Why Sql-operator? \u00b6 Make onboarding new projects simple. Ensure the correct permssions (and nothing more) is provisioned. Keep track of remote Sql assets. Ensure permissions don't change over time. Documentation \u00b6 Getting started \u00b6 For set-up information and deploying your first Sql assets, please see our Getting started guide. Examples \u00b6 For detailed examples about what Sql-operator can do, please see our example .","title":"Overview"},{"location":"#what-is-sql-operator","text":"SQL-operator is a component that managed SQL resources for you. SQL-operator is implemented as a Kubernetes CRD (Custom Resource Definition). Create SQL assets using Infrastructure as Code . Easily create and destroy integration environments.","title":"What is Sql-operator"},{"location":"#why-sql-operator","text":"Make onboarding new projects simple. Ensure the correct permssions (and nothing more) is provisioned. Keep track of remote Sql assets. Ensure permissions don't change over time.","title":"Why Sql-operator?"},{"location":"#documentation","text":"","title":"Documentation"},{"location":"#getting-started","text":"For set-up information and deploying your first Sql assets, please see our Getting started guide.","title":"Getting started"},{"location":"#examples","text":"For detailed examples about what Sql-operator can do, please see our example .","title":"Examples"},{"location":"core-concepts/","text":"Core concepts \u00b6 Sql-operator aims to solve 3 different cases when dealing with Sql resources. Create \u00b6 Simplify creation of Sql resouces that are dependecies of your application. You define what database, user and grants you want and Sql-operator will ensure they are created. Reconcile \u00b6 At set intervals (default 10 seconds) sql-operator will validate if the resources are still in the desired state. If not it will re-apply the wanted state. This adds an additional layer of control. Cleanup \u00b6 If configured using the cleanupPolicy , sql-operator will delete the external resouces. This way your resources stay clean.","title":"Core concepts"},{"location":"core-concepts/#core-concepts","text":"Sql-operator aims to solve 3 different cases when dealing with Sql resources.","title":"Core concepts"},{"location":"core-concepts/#create","text":"Simplify creation of Sql resouces that are dependecies of your application. You define what database, user and grants you want and Sql-operator will ensure they are created.","title":"Create"},{"location":"core-concepts/#reconcile","text":"At set intervals (default 10 seconds) sql-operator will validate if the resources are still in the desired state. If not it will re-apply the wanted state. This adds an additional layer of control.","title":"Reconcile"},{"location":"core-concepts/#cleanup","text":"If configured using the cleanupPolicy , sql-operator will delete the external resouces. This way your resources stay clean.","title":"Cleanup"},{"location":"crds/","text":"CRDs \u00b6 # sqlhosts.stenic.io apiVersion : stenic.io/v1alpha1 kind : SqlHost metadata : name : integration spec : engine : Mysql dsn : sqloperator:xxxxxxxxxxx@tcp(192.168.1.123:3306)/ # sqldatabase.stenic.io apiVersion : stenic.io/v1alpha1 kind : SqlDatabase metadata : name : application-int-db spec : databaseName : myapp_testing hostRef : name : integration cleanupPolicy : Delete # sqluser.stenic.io apiVersion : stenic.io/v1alpha1 kind : SqlUser metadata : name : application-int-user spec : credentials : username : myapp_username password : myapp_password hostRef : name : integration cleanupPolicy : Delete # sqlgrant.stenic.io apiVersion : stenic.io/v1alpha1 kind : SqlGrant metadata : name : application-int-grant spec : userRef : name : application-int-user databaseRef : name : application-int-db grants : - INSERT - SELECT - UPDATE - DELETE cleanupPolicy : Delete","title":"CRDs"},{"location":"crds/#crds","text":"# sqlhosts.stenic.io apiVersion : stenic.io/v1alpha1 kind : SqlHost metadata : name : integration spec : engine : Mysql dsn : sqloperator:xxxxxxxxxxx@tcp(192.168.1.123:3306)/ # sqldatabase.stenic.io apiVersion : stenic.io/v1alpha1 kind : SqlDatabase metadata : name : application-int-db spec : databaseName : myapp_testing hostRef : name : integration cleanupPolicy : Delete # sqluser.stenic.io apiVersion : stenic.io/v1alpha1 kind : SqlUser metadata : name : application-int-user spec : credentials : username : myapp_username password : myapp_password hostRef : name : integration cleanupPolicy : Delete # sqlgrant.stenic.io apiVersion : stenic.io/v1alpha1 kind : SqlGrant metadata : name : application-int-grant spec : userRef : name : application-int-user databaseRef : name : application-int-db grants : - INSERT - SELECT - UPDATE - DELETE cleanupPolicy : Delete","title":"CRDs"},{"location":"getting-started/","text":"Getting started \u00b6 To see how Sql-operator works, you can install it and configure some examples. Firstly, you'll need a Kubernetes cluster, kubectl and helm set-up Installing Sql-operator \u00b6 To get started quickly, you can use the helm chart which will install Sql-operator: helm repo add sql-operator https://stenic.github.io/sql-operator/ helm install sql-operator --namespace sql-operator --create-namespace sql-operator/sql-operator Note The examples will use an in-cluster database for demo simplicity. Please use the following command to install it. helm repo add bitnami https://charts.bitnami.com/bitnami helm install test-db \\ --namespace sql-operator-testdb --create-namespace \\ --set auth.rootPassword = n0tS3cur3 \\ --set primary.persistence.enabled = false \\ --set secondary.persistence.enabled = false \\ bitnami/mariadb Define an host you want to manage \u00b6 First of, we will need to configure one or more SqlHost objects. These object are used by sql-operator to grab the endpoint and the correct credentials. kubectl apply -f https://raw.githubusercontent.com/stenic/sql-operator/master/examples/sqlhost-mysql.yaml kubectl get sqlhost Note If you didn't install the in-cluster database, you can alter the manifest. kubectl edit sqlhost sample-host Create a database, user and grants \u00b6 Not that we have a host defined, we can create our first assets. kubectl apply -f https://raw.githubusercontent.com/stenic/sql-operator/master/examples/sqldatabase-gettingstarted.yaml kubectl apply -f https://raw.githubusercontent.com/stenic/sql-operator/master/examples/sqluser-gettingstarted.yaml kubectl apply -f https://raw.githubusercontent.com/stenic/sql-operator/master/examples/sqlgrant-gettingstarted.yaml Let's verify our resources got created. (Password is n0tS3cur3 ) kubectl exec -ti -n sql-operator-testdb test-db-mariadb-0 -- mysql -uroot -p -e 'show databases;' kubectl exec -ti -n sql-operator-testdb test-db-mariadb-0 -- mysql -uroot -p -e 'select user from mysql.user;' kubectl exec -ti -n sql-operator-testdb test-db-mariadb-0 -- mysql -uroot -p -e 'show grants for sample_username;'","title":"Getting started"},{"location":"getting-started/#getting-started","text":"To see how Sql-operator works, you can install it and configure some examples. Firstly, you'll need a Kubernetes cluster, kubectl and helm set-up","title":"Getting started"},{"location":"getting-started/#installing-sql-operator","text":"To get started quickly, you can use the helm chart which will install Sql-operator: helm repo add sql-operator https://stenic.github.io/sql-operator/ helm install sql-operator --namespace sql-operator --create-namespace sql-operator/sql-operator Note The examples will use an in-cluster database for demo simplicity. Please use the following command to install it. helm repo add bitnami https://charts.bitnami.com/bitnami helm install test-db \\ --namespace sql-operator-testdb --create-namespace \\ --set auth.rootPassword = n0tS3cur3 \\ --set primary.persistence.enabled = false \\ --set secondary.persistence.enabled = false \\ bitnami/mariadb","title":"Installing Sql-operator"},{"location":"getting-started/#define-an-host-you-want-to-manage","text":"First of, we will need to configure one or more SqlHost objects. These object are used by sql-operator to grab the endpoint and the correct credentials. kubectl apply -f https://raw.githubusercontent.com/stenic/sql-operator/master/examples/sqlhost-mysql.yaml kubectl get sqlhost Note If you didn't install the in-cluster database, you can alter the manifest. kubectl edit sqlhost sample-host","title":"Define an host you want to manage"},{"location":"getting-started/#create-a-database-user-and-grants","text":"Not that we have a host defined, we can create our first assets. kubectl apply -f https://raw.githubusercontent.com/stenic/sql-operator/master/examples/sqldatabase-gettingstarted.yaml kubectl apply -f https://raw.githubusercontent.com/stenic/sql-operator/master/examples/sqluser-gettingstarted.yaml kubectl apply -f https://raw.githubusercontent.com/stenic/sql-operator/master/examples/sqlgrant-gettingstarted.yaml Let's verify our resources got created. (Password is n0tS3cur3 ) kubectl exec -ti -n sql-operator-testdb test-db-mariadb-0 -- mysql -uroot -p -e 'show databases;' kubectl exec -ti -n sql-operator-testdb test-db-mariadb-0 -- mysql -uroot -p -e 'select user from mysql.user;' kubectl exec -ti -n sql-operator-testdb test-db-mariadb-0 -- mysql -uroot -p -e 'show grants for sample_username;'","title":"Create a database, user and grants"},{"location":"extras/argocd/","text":"ArgoCD \u00b6 When installing using ArgoCD you will need to tell ArgoCD to ignore some changes. The helm chart makes use of genSignedCert to configure and secure the webhooks. Because of this implementation, each helm template will cause a change and will as a result keep creating differences for ArgoCD to deploy. Luckily ArgoCD has a buildin mechanism to handle these kinds of workflows. The example below can be used to ignore these changes. apiVersion : argoproj.io/v1alpha1 kind : Application spec : ignoreDifferences : - group : admissionregistration.k8s.io kind : ValidatingWebhookConfiguration jsonPointers : - /webhooks/0/clientConfig/caBundle - /webhooks/1/clientConfig/caBundle - group : admissionregistration.k8s.io kind : MutatingWebhookConfiguration jsonPointers : - /webhooks/0/clientConfig/caBundle - /webhooks/1/clientConfig/caBundle - group : \"\" kind : Secret jsonPointers : - /data/tls.key - /data/tls.crt - group : \"apps\" kind : Deployment jsonPointers : - /spec/template/metadata/annotations/checksum~1admission-webhook.yaml","title":"ArgoCD"},{"location":"extras/argocd/#argocd","text":"When installing using ArgoCD you will need to tell ArgoCD to ignore some changes. The helm chart makes use of genSignedCert to configure and secure the webhooks. Because of this implementation, each helm template will cause a change and will as a result keep creating differences for ArgoCD to deploy. Luckily ArgoCD has a buildin mechanism to handle these kinds of workflows. The example below can be used to ignore these changes. apiVersion : argoproj.io/v1alpha1 kind : Application spec : ignoreDifferences : - group : admissionregistration.k8s.io kind : ValidatingWebhookConfiguration jsonPointers : - /webhooks/0/clientConfig/caBundle - /webhooks/1/clientConfig/caBundle - group : admissionregistration.k8s.io kind : MutatingWebhookConfiguration jsonPointers : - /webhooks/0/clientConfig/caBundle - /webhooks/1/clientConfig/caBundle - group : \"\" kind : Secret jsonPointers : - /data/tls.key - /data/tls.crt - group : \"apps\" kind : Deployment jsonPointers : - /spec/template/metadata/annotations/checksum~1admission-webhook.yaml","title":"ArgoCD"},{"location":"extras/ownership/","text":"Ownership \u00b6 Sql-operator comes with ownership tracking since v1.13.0 . Ownership tracking ensures that only 1 object can alter the Sql resources. Each time an object gets reconciled, a check will be performed to validate that the kubernetes object is indeed the object managing the Sql resource. An additional status field has been added called OwnerID . The tracking is implemented on each driver. The following checks are performed: Is the object known in the reference table? -> YES: Does the OwnerID match? -> YES: IsOwner -> NO: NotOwner -> NO: Does the resource exist? -> YES: NotOwner -> NO: NonExisting","title":"Ownership"},{"location":"extras/ownership/#ownership","text":"Sql-operator comes with ownership tracking since v1.13.0 . Ownership tracking ensures that only 1 object can alter the Sql resources. Each time an object gets reconciled, a check will be performed to validate that the kubernetes object is indeed the object managing the Sql resource. An additional status field has been added called OwnerID . The tracking is implemented on each driver. The following checks are performed: Is the object known in the reference table? -> YES: Does the OwnerID match? -> YES: IsOwner -> NO: NotOwner -> NO: Does the resource exist? -> YES: NotOwner -> NO: NonExisting","title":"Ownership"}]}